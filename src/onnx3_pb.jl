# Autogenerated using ProtoBuf.jl v1.0.6 on 2022-09-11T11:55:17.043
# original file: /home/azbs/work/onnx/onnx/onnx.proto3 (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using EnumX: @enumx

export Version, var"TensorProto.Segment", var"TensorShapeProto.Dimension"
export StringStringEntryProto, OperatorStatus, OperatorSetIdProto
export var"TensorProto.DataLocation", var"AttributeProto.AttributeType"
export var"TensorProto.DataType", TensorShapeProto, TensorAnnotation, TensorProto
export var"TypeProto.SparseTensor", var"TypeProto.Tensor", SparseTensorProto, GraphProto
export ModelProto, AttributeProto, NodeProto, var"TypeProto.Sequence", TypeProto
export var"TypeProto.Optional", var"TypeProto.Map", ValueInfoProto, TrainingInfoProto
export FunctionProto

# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractGraphProto" end
abstract type var"##AbstractModelProto" end
abstract type var"##AbstractAttributeProto" end
abstract type var"##AbstractNodeProto" end
abstract type var"##AbstractTypeProto.Sequence" end
abstract type var"##AbstractTypeProto" end
abstract type var"##AbstractTypeProto.Optional" end
abstract type var"##AbstractTypeProto.Map" end
abstract type var"##AbstractValueInfoProto" end
abstract type var"##AbstractTrainingInfoProto" end
abstract type var"##AbstractFunctionProto" end


@enumx Version _START_VERSION=0 IR_VERSION_2017_10_10=1 IR_VERSION_2017_10_30=2 IR_VERSION_2017_11_3=3 IR_VERSION_2019_1_22=4 IR_VERSION_2019_3_18=5 IR_VERSION_2019_9_19=6 IR_VERSION_2020_5_8=7 IR_VERSION=8

struct var"TensorProto.Segment"
    var"#begin"::Int64
    var"#end"::Int64
end
var"TensorProto.Segment"(;var"#begin" = zero(Int64), var"#end" = zero(Int64)) = var"TensorProto.Segment"(var"#begin", var"#end")
PB.default_values(::Type{var"TensorProto.Segment"}) = (;var"#begin" = zero(Int64), var"#end" = zero(Int64))
PB.field_numbers(::Type{var"TensorProto.Segment"}) = (;var"#begin" = 1, var"#end" = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TensorProto.Segment"})
    var"#begin" = zero(Int64)
    var"#end" = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var"#begin" = PB.decode(d, Int64)
        elseif field_number == 2
            var"#end" = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TensorProto.Segment"(var"#begin", var"#end")
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TensorProto.Segment")
    initpos = position(e.io)
    x.var"#begin" != zero(Int64) && PB.encode(e, 1, x.var"#begin")
    x.var"#end" != zero(Int64) && PB.encode(e, 2, x.var"#end")
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TensorProto.Segment")
    encoded_size = 0
    x.var"#begin" != zero(Int64) && (encoded_size += PB._encoded_size(x.var"#begin", 1))
    x.var"#end" != zero(Int64) && (encoded_size += PB._encoded_size(x.var"#end", 2))
    return encoded_size
end

struct var"TensorShapeProto.Dimension"
    value::Union{Nothing,OneOf{<:Union{Int64,String}}}
    denotation::String
end
var"TensorShapeProto.Dimension"(;value = nothing, denotation = "") = var"TensorShapeProto.Dimension"(value, denotation)
PB.oneof_field_types(::Type{var"TensorShapeProto.Dimension"}) = (;
    value = (;dim_value=Int64, dim_param=String),
)
PB.default_values(::Type{var"TensorShapeProto.Dimension"}) = (;dim_value = zero(Int64), dim_param = "", denotation = "")
PB.field_numbers(::Type{var"TensorShapeProto.Dimension"}) = (;dim_value = 1, dim_param = 2, denotation = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TensorShapeProto.Dimension"})
    value = nothing
    denotation = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            value = OneOf(:dim_value, PB.decode(d, Int64))
        elseif field_number == 2
            value = OneOf(:dim_param, PB.decode(d, String))
        elseif field_number == 3
            denotation = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TensorShapeProto.Dimension"(value, denotation)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TensorShapeProto.Dimension")
    initpos = position(e.io)
    if isnothing(x.value);
    elseif x.value.name === :dim_value
        PB.encode(e, 1, x.value[])
    elseif x.value.name === :dim_param
        PB.encode(e, 2, x.value[])
    end
    !isempty(x.denotation) && PB.encode(e, 3, x.denotation)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TensorShapeProto.Dimension")
    encoded_size = 0
    if isnothing(x.value);
    elseif x.value.name === :dim_value
        encoded_size += PB._encoded_size(x.value[], 1)
    elseif x.value.name === :dim_param
        encoded_size += PB._encoded_size(x.value[], 2)
    end
    !isempty(x.denotation) && (encoded_size += PB._encoded_size(x.denotation, 3))
    return encoded_size
end

struct StringStringEntryProto
    key::String
    value::String
end
StringStringEntryProto(;key = "", value = "") = StringStringEntryProto(key, value)
PB.default_values(::Type{StringStringEntryProto}) = (;key = "", value = "")
PB.field_numbers(::Type{StringStringEntryProto}) = (;key = 1, value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:StringStringEntryProto})
    key = ""
    value = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            key = PB.decode(d, String)
        elseif field_number == 2
            value = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return StringStringEntryProto(key, value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::StringStringEntryProto)
    initpos = position(e.io)
    !isempty(x.key) && PB.encode(e, 1, x.key)
    !isempty(x.value) && PB.encode(e, 2, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::StringStringEntryProto)
    encoded_size = 0
    !isempty(x.key) && (encoded_size += PB._encoded_size(x.key, 1))
    !isempty(x.value) && (encoded_size += PB._encoded_size(x.value, 2))
    return encoded_size
end

@enumx OperatorStatus EXPERIMENTAL=0 STABLE=1

struct OperatorSetIdProto
    domain::String
    version::Int64
end
OperatorSetIdProto(;domain = "", version = zero(Int64)) = OperatorSetIdProto(domain, version)
PB.default_values(::Type{OperatorSetIdProto}) = (;domain = "", version = zero(Int64))
PB.field_numbers(::Type{OperatorSetIdProto}) = (;domain = 1, version = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OperatorSetIdProto})
    domain = ""
    version = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            domain = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return OperatorSetIdProto(domain, version)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OperatorSetIdProto)
    initpos = position(e.io)
    !isempty(x.domain) && PB.encode(e, 1, x.domain)
    x.version != zero(Int64) && PB.encode(e, 2, x.version)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OperatorSetIdProto)
    encoded_size = 0
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 1))
    x.version != zero(Int64) && (encoded_size += PB._encoded_size(x.version, 2))
    return encoded_size
end

@enumx var"TensorProto.DataLocation" DEFAULT=0 EXTERNAL=1

@enumx var"AttributeProto.AttributeType" UNDEFINED=0 FLOAT=1 INT=2 STRING=3 TENSOR=4 GRAPH=5 SPARSE_TENSOR=11 TYPE_PROTO=13 FLOATS=6 INTS=7 STRINGS=8 TENSORS=9 GRAPHS=10 SPARSE_TENSORS=12 TYPE_PROTOS=14

@enumx var"TensorProto.DataType" UNDEFINED=0 FLOAT=1 UINT8=2 INT8=3 UINT16=4 INT16=5 INT32=6 INT64=7 STRING=8 BOOL=9 FLOAT16=10 DOUBLE=11 UINT32=12 UINT64=13 COMPLEX64=14 COMPLEX128=15 BFLOAT16=16

struct TensorShapeProto
    dim::Vector{var"TensorShapeProto.Dimension"}
end
TensorShapeProto(;dim = Vector{var"TensorShapeProto.Dimension"}()) = TensorShapeProto(dim)
PB.default_values(::Type{TensorShapeProto}) = (;dim = Vector{var"TensorShapeProto.Dimension"}())
PB.field_numbers(::Type{TensorShapeProto}) = (;dim = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TensorShapeProto})
    dim = PB.BufferedVector{var"TensorShapeProto.Dimension"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, dim)
        else
            PB.skip(d, wire_type)
        end
    end
    return TensorShapeProto(dim[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TensorShapeProto)
    initpos = position(e.io)
    !isempty(x.dim) && PB.encode(e, 1, x.dim)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TensorShapeProto)
    encoded_size = 0
    !isempty(x.dim) && (encoded_size += PB._encoded_size(x.dim, 1))
    return encoded_size
end

struct TensorAnnotation
    tensor_name::String
    quant_parameter_tensor_names::Vector{StringStringEntryProto}
end
TensorAnnotation(;tensor_name = "", quant_parameter_tensor_names = Vector{StringStringEntryProto}()) = TensorAnnotation(tensor_name, quant_parameter_tensor_names)
PB.default_values(::Type{TensorAnnotation}) = (;tensor_name = "", quant_parameter_tensor_names = Vector{StringStringEntryProto}())
PB.field_numbers(::Type{TensorAnnotation}) = (;tensor_name = 1, quant_parameter_tensor_names = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TensorAnnotation})
    tensor_name = ""
    quant_parameter_tensor_names = PB.BufferedVector{StringStringEntryProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            tensor_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, quant_parameter_tensor_names)
        else
            PB.skip(d, wire_type)
        end
    end
    return TensorAnnotation(tensor_name, quant_parameter_tensor_names[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TensorAnnotation)
    initpos = position(e.io)
    !isempty(x.tensor_name) && PB.encode(e, 1, x.tensor_name)
    !isempty(x.quant_parameter_tensor_names) && PB.encode(e, 2, x.quant_parameter_tensor_names)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TensorAnnotation)
    encoded_size = 0
    !isempty(x.tensor_name) && (encoded_size += PB._encoded_size(x.tensor_name, 1))
    !isempty(x.quant_parameter_tensor_names) && (encoded_size += PB._encoded_size(x.quant_parameter_tensor_names, 2))
    return encoded_size
end

struct TensorProto
    dims::Vector{Int64}
    data_type::Int32
    segment::Union{Nothing,var"TensorProto.Segment"}
    float_data::Vector{Float32}
    int32_data::Vector{Int32}
    string_data::Vector{Vector{UInt8}}
    int64_data::Vector{Int64}
    name::String
    doc_string::String
    raw_data::Vector{UInt8}
    external_data::Vector{StringStringEntryProto}
    data_location::var"TensorProto.DataLocation".T
    double_data::Vector{Float64}
    uint64_data::Vector{UInt64}
end
TensorProto(;dims = Vector{Int64}(), data_type = zero(Int32), segment = nothing, float_data = Vector{Float32}(), int32_data = Vector{Int32}(), string_data = Vector{Vector{UInt8}}(), int64_data = Vector{Int64}(), name = "", doc_string = "", raw_data = UInt8[], external_data = Vector{StringStringEntryProto}(), data_location = var"TensorProto.DataLocation".DEFAULT, double_data = Vector{Float64}(), uint64_data = Vector{UInt64}()) = TensorProto(dims, data_type, segment, float_data, int32_data, string_data, int64_data, name, doc_string, raw_data, external_data, data_location, double_data, uint64_data)
PB.default_values(::Type{TensorProto}) = (;dims = Vector{Int64}(), data_type = zero(Int32), segment = nothing, float_data = Vector{Float32}(), int32_data = Vector{Int32}(), string_data = Vector{Vector{UInt8}}(), int64_data = Vector{Int64}(), name = "", doc_string = "", raw_data = UInt8[], external_data = Vector{StringStringEntryProto}(), data_location = var"TensorProto.DataLocation".DEFAULT, double_data = Vector{Float64}(), uint64_data = Vector{UInt64}())
PB.field_numbers(::Type{TensorProto}) = (;dims = 1, data_type = 2, segment = 3, float_data = 4, int32_data = 5, string_data = 6, int64_data = 7, name = 8, doc_string = 12, raw_data = 9, external_data = 13, data_location = 14, double_data = 10, uint64_data = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TensorProto})
    dims = PB.BufferedVector{Int64}()
    data_type = zero(Int32)
    segment = Ref{Union{Nothing,var"TensorProto.Segment"}}(nothing)
    float_data = PB.BufferedVector{Float32}()
    int32_data = PB.BufferedVector{Int32}()
    string_data = PB.BufferedVector{Vector{UInt8}}()
    int64_data = PB.BufferedVector{Int64}()
    name = ""
    doc_string = ""
    raw_data = UInt8[]
    external_data = PB.BufferedVector{StringStringEntryProto}()
    data_location = var"TensorProto.DataLocation".DEFAULT
    double_data = PB.BufferedVector{Float64}()
    uint64_data = PB.BufferedVector{UInt64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, dims)
        elseif field_number == 2
            data_type = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, segment)
        elseif field_number == 4
            PB.decode!(d, wire_type, float_data)
        elseif field_number == 5
            PB.decode!(d, wire_type, int32_data)
        elseif field_number == 6
            PB.decode!(d, string_data)
        elseif field_number == 7
            PB.decode!(d, wire_type, int64_data)
        elseif field_number == 8
            name = PB.decode(d, String)
        elseif field_number == 12
            doc_string = PB.decode(d, String)
        elseif field_number == 9
            raw_data = PB.decode(d, Vector{UInt8})
        elseif field_number == 13
            PB.decode!(d, external_data)
        elseif field_number == 14
            data_location = PB.decode(d, var"TensorProto.DataLocation".T)
        elseif field_number == 10
            PB.decode!(d, wire_type, double_data)
        elseif field_number == 11
            PB.decode!(d, wire_type, uint64_data)
        else
            PB.skip(d, wire_type)
        end
    end
    return TensorProto(dims[], data_type, segment[], float_data[], int32_data[], string_data[], int64_data[], name, doc_string, raw_data, external_data[], data_location, double_data[], uint64_data[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TensorProto)
    initpos = position(e.io)
    !isempty(x.dims) && PB.encode(e, 1, x.dims)
    x.data_type != zero(Int32) && PB.encode(e, 2, x.data_type)
    !isnothing(x.segment) && PB.encode(e, 3, x.segment)
    !isempty(x.float_data) && PB.encode(e, 4, x.float_data)
    !isempty(x.int32_data) && PB.encode(e, 5, x.int32_data)
    !isempty(x.string_data) && PB.encode(e, 6, x.string_data)
    !isempty(x.int64_data) && PB.encode(e, 7, x.int64_data)
    !isempty(x.name) && PB.encode(e, 8, x.name)
    !isempty(x.doc_string) && PB.encode(e, 12, x.doc_string)
    !isempty(x.raw_data) && PB.encode(e, 9, x.raw_data)
    !isempty(x.external_data) && PB.encode(e, 13, x.external_data)
    x.data_location != var"TensorProto.DataLocation".DEFAULT && PB.encode(e, 14, x.data_location)
    !isempty(x.double_data) && PB.encode(e, 10, x.double_data)
    !isempty(x.uint64_data) && PB.encode(e, 11, x.uint64_data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TensorProto)
    encoded_size = 0
    !isempty(x.dims) && (encoded_size += PB._encoded_size(x.dims, 1))
    x.data_type != zero(Int32) && (encoded_size += PB._encoded_size(x.data_type, 2))
    !isnothing(x.segment) && (encoded_size += PB._encoded_size(x.segment, 3))
    !isempty(x.float_data) && (encoded_size += PB._encoded_size(x.float_data, 4))
    !isempty(x.int32_data) && (encoded_size += PB._encoded_size(x.int32_data, 5))
    !isempty(x.string_data) && (encoded_size += PB._encoded_size(x.string_data, 6))
    !isempty(x.int64_data) && (encoded_size += PB._encoded_size(x.int64_data, 7))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 8))
    !isempty(x.doc_string) && (encoded_size += PB._encoded_size(x.doc_string, 12))
    !isempty(x.raw_data) && (encoded_size += PB._encoded_size(x.raw_data, 9))
    !isempty(x.external_data) && (encoded_size += PB._encoded_size(x.external_data, 13))
    x.data_location != var"TensorProto.DataLocation".DEFAULT && (encoded_size += PB._encoded_size(x.data_location, 14))
    !isempty(x.double_data) && (encoded_size += PB._encoded_size(x.double_data, 10))
    !isempty(x.uint64_data) && (encoded_size += PB._encoded_size(x.uint64_data, 11))
    return encoded_size
end

struct var"TypeProto.SparseTensor"
    elem_type::Int32
    shape::Union{Nothing,TensorShapeProto}
end
var"TypeProto.SparseTensor"(;elem_type = zero(Int32), shape = nothing) = var"TypeProto.SparseTensor"(elem_type, shape)
PB.default_values(::Type{var"TypeProto.SparseTensor"}) = (;elem_type = zero(Int32), shape = nothing)
PB.field_numbers(::Type{var"TypeProto.SparseTensor"}) = (;elem_type = 1, shape = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TypeProto.SparseTensor"})
    elem_type = zero(Int32)
    shape = Ref{Union{Nothing,TensorShapeProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            elem_type = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, shape)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TypeProto.SparseTensor"(elem_type, shape[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TypeProto.SparseTensor")
    initpos = position(e.io)
    x.elem_type != zero(Int32) && PB.encode(e, 1, x.elem_type)
    !isnothing(x.shape) && PB.encode(e, 2, x.shape)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TypeProto.SparseTensor")
    encoded_size = 0
    x.elem_type != zero(Int32) && (encoded_size += PB._encoded_size(x.elem_type, 1))
    !isnothing(x.shape) && (encoded_size += PB._encoded_size(x.shape, 2))
    return encoded_size
end

struct var"TypeProto.Tensor"
    elem_type::Int32
    shape::Union{Nothing,TensorShapeProto}
end
var"TypeProto.Tensor"(;elem_type = zero(Int32), shape = nothing) = var"TypeProto.Tensor"(elem_type, shape)
PB.default_values(::Type{var"TypeProto.Tensor"}) = (;elem_type = zero(Int32), shape = nothing)
PB.field_numbers(::Type{var"TypeProto.Tensor"}) = (;elem_type = 1, shape = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TypeProto.Tensor"})
    elem_type = zero(Int32)
    shape = Ref{Union{Nothing,TensorShapeProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            elem_type = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, shape)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TypeProto.Tensor"(elem_type, shape[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TypeProto.Tensor")
    initpos = position(e.io)
    x.elem_type != zero(Int32) && PB.encode(e, 1, x.elem_type)
    !isnothing(x.shape) && PB.encode(e, 2, x.shape)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TypeProto.Tensor")
    encoded_size = 0
    x.elem_type != zero(Int32) && (encoded_size += PB._encoded_size(x.elem_type, 1))
    !isnothing(x.shape) && (encoded_size += PB._encoded_size(x.shape, 2))
    return encoded_size
end

struct SparseTensorProto
    values::Union{Nothing,TensorProto}
    indices::Union{Nothing,TensorProto}
    dims::Vector{Int64}
end
SparseTensorProto(;values = nothing, indices = nothing, dims = Vector{Int64}()) = SparseTensorProto(values, indices, dims)
PB.default_values(::Type{SparseTensorProto}) = (;values = nothing, indices = nothing, dims = Vector{Int64}())
PB.field_numbers(::Type{SparseTensorProto}) = (;values = 1, indices = 2, dims = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SparseTensorProto})
    values = Ref{Union{Nothing,TensorProto}}(nothing)
    indices = Ref{Union{Nothing,TensorProto}}(nothing)
    dims = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, values)
        elseif field_number == 2
            PB.decode!(d, indices)
        elseif field_number == 3
            PB.decode!(d, wire_type, dims)
        else
            PB.skip(d, wire_type)
        end
    end
    return SparseTensorProto(values[], indices[], dims[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SparseTensorProto)
    initpos = position(e.io)
    !isnothing(x.values) && PB.encode(e, 1, x.values)
    !isnothing(x.indices) && PB.encode(e, 2, x.indices)
    !isempty(x.dims) && PB.encode(e, 3, x.dims)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SparseTensorProto)
    encoded_size = 0
    !isnothing(x.values) && (encoded_size += PB._encoded_size(x.values, 1))
    !isnothing(x.indices) && (encoded_size += PB._encoded_size(x.indices, 2))
    !isempty(x.dims) && (encoded_size += PB._encoded_size(x.dims, 3))
    return encoded_size
end

struct GraphProto{T4<:Union{Nothing,var"##AbstractValueInfoProto"},T3<:Union{Nothing,var"##AbstractValueInfoProto"},T1<:Union{Nothing,var"##AbstractNodeProto"},T2<:Union{Nothing,var"##AbstractValueInfoProto"}} <: var"##AbstractGraphProto"
    node::Vector{T1}
    name::String
    initializer::Vector{TensorProto}
    sparse_initializer::Vector{SparseTensorProto}
    doc_string::String
    input::Vector{T2}
    output::Vector{T3}
    value_info::Vector{T4}
    quantization_annotation::Vector{TensorAnnotation}
end
GraphProto(;node = Vector{NodeProto}(), name = "", initializer = Vector{TensorProto}(), sparse_initializer = Vector{SparseTensorProto}(), doc_string = "", input = Vector{ValueInfoProto}(), output = Vector{ValueInfoProto}(), value_info = Vector{ValueInfoProto}(), quantization_annotation = Vector{TensorAnnotation}()) = GraphProto(node, name, initializer, sparse_initializer, doc_string, input, output, value_info, quantization_annotation)
PB.reserved_fields(::Type{GraphProto}) = (names = ["ir_version", "producer_version", "producer_tag", "domain"], numbers = Union{Int,UnitRange{Int}}[3, 4, 6:9])
PB.default_values(::Type{GraphProto}) = (;node = Vector{NodeProto}(), name = "", initializer = Vector{TensorProto}(), sparse_initializer = Vector{SparseTensorProto}(), doc_string = "", input = Vector{ValueInfoProto}(), output = Vector{ValueInfoProto}(), value_info = Vector{ValueInfoProto}(), quantization_annotation = Vector{TensorAnnotation}())
PB.field_numbers(::Type{GraphProto}) = (;node = 1, name = 2, initializer = 5, sparse_initializer = 15, doc_string = 10, input = 11, output = 12, value_info = 13, quantization_annotation = 14)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GraphProto})
    node = PB.BufferedVector{NodeProto}()
    name = ""
    initializer = PB.BufferedVector{TensorProto}()
    sparse_initializer = PB.BufferedVector{SparseTensorProto}()
    doc_string = ""
    input = PB.BufferedVector{ValueInfoProto}()
    output = PB.BufferedVector{ValueInfoProto}()
    value_info = PB.BufferedVector{ValueInfoProto}()
    quantization_annotation = PB.BufferedVector{TensorAnnotation}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, node)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, initializer)
        elseif field_number == 15
            PB.decode!(d, sparse_initializer)
        elseif field_number == 10
            doc_string = PB.decode(d, String)
        elseif field_number == 11
            PB.decode!(d, input)
        elseif field_number == 12
            PB.decode!(d, output)
        elseif field_number == 13
            PB.decode!(d, value_info)
        elseif field_number == 14
            PB.decode!(d, quantization_annotation)
        else
            PB.skip(d, wire_type)
        end
    end
    return GraphProto(node[], name, initializer[], sparse_initializer[], doc_string, input[], output[], value_info[], quantization_annotation[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GraphProto)
    initpos = position(e.io)
    !isempty(x.node) && PB.encode(e, 1, x.node)
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.initializer) && PB.encode(e, 5, x.initializer)
    !isempty(x.sparse_initializer) && PB.encode(e, 15, x.sparse_initializer)
    !isempty(x.doc_string) && PB.encode(e, 10, x.doc_string)
    !isempty(x.input) && PB.encode(e, 11, x.input)
    !isempty(x.output) && PB.encode(e, 12, x.output)
    !isempty(x.value_info) && PB.encode(e, 13, x.value_info)
    !isempty(x.quantization_annotation) && PB.encode(e, 14, x.quantization_annotation)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GraphProto)
    encoded_size = 0
    !isempty(x.node) && (encoded_size += PB._encoded_size(x.node, 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.initializer) && (encoded_size += PB._encoded_size(x.initializer, 5))
    !isempty(x.sparse_initializer) && (encoded_size += PB._encoded_size(x.sparse_initializer, 15))
    !isempty(x.doc_string) && (encoded_size += PB._encoded_size(x.doc_string, 10))
    !isempty(x.input) && (encoded_size += PB._encoded_size(x.input, 11))
    !isempty(x.output) && (encoded_size += PB._encoded_size(x.output, 12))
    !isempty(x.value_info) && (encoded_size += PB._encoded_size(x.value_info, 13))
    !isempty(x.quantization_annotation) && (encoded_size += PB._encoded_size(x.quantization_annotation, 14))
    return encoded_size
end

struct ModelProto{T1<:Union{Nothing,var"##AbstractTrainingInfoProto"},T2<:Union{Nothing,var"##AbstractFunctionProto"}} <: var"##AbstractModelProto"
    ir_version::Int64
    opset_import::Vector{OperatorSetIdProto}
    producer_name::String
    producer_version::String
    domain::String
    model_version::Int64
    doc_string::String
    graph::Union{Nothing,GraphProto}
    metadata_props::Vector{StringStringEntryProto}
    training_info::Vector{T1}
    functions::Vector{T2}
end
ModelProto(;ir_version = zero(Int64), opset_import = Vector{OperatorSetIdProto}(), producer_name = "", producer_version = "", domain = "", model_version = zero(Int64), doc_string = "", graph = nothing, metadata_props = Vector{StringStringEntryProto}(), training_info = Vector{TrainingInfoProto}(), functions = Vector{FunctionProto}()) = ModelProto(ir_version, opset_import, producer_name, producer_version, domain, model_version, doc_string, graph, metadata_props, training_info, functions)
PB.default_values(::Type{ModelProto}) = (;ir_version = zero(Int64), opset_import = Vector{OperatorSetIdProto}(), producer_name = "", producer_version = "", domain = "", model_version = zero(Int64), doc_string = "", graph = nothing, metadata_props = Vector{StringStringEntryProto}(), training_info = Vector{TrainingInfoProto}(), functions = Vector{FunctionProto}())
PB.field_numbers(::Type{ModelProto}) = (;ir_version = 1, opset_import = 8, producer_name = 2, producer_version = 3, domain = 4, model_version = 5, doc_string = 6, graph = 7, metadata_props = 14, training_info = 20, functions = 25)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelProto})
    ir_version = zero(Int64)
    opset_import = PB.BufferedVector{OperatorSetIdProto}()
    producer_name = ""
    producer_version = ""
    domain = ""
    model_version = zero(Int64)
    doc_string = ""
    graph = Ref{Union{Nothing,GraphProto}}(nothing)
    metadata_props = PB.BufferedVector{StringStringEntryProto}()
    training_info = PB.BufferedVector{TrainingInfoProto}()
    functions = PB.BufferedVector{FunctionProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            ir_version = PB.decode(d, Int64)
        elseif field_number == 8
            PB.decode!(d, opset_import)
        elseif field_number == 2
            producer_name = PB.decode(d, String)
        elseif field_number == 3
            producer_version = PB.decode(d, String)
        elseif field_number == 4
            domain = PB.decode(d, String)
        elseif field_number == 5
            model_version = PB.decode(d, Int64)
        elseif field_number == 6
            doc_string = PB.decode(d, String)
        elseif field_number == 7
            PB.decode!(d, graph)
        elseif field_number == 14
            PB.decode!(d, metadata_props)
        elseif field_number == 20
            PB.decode!(d, training_info)
        elseif field_number == 25
            PB.decode!(d, functions)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelProto(ir_version, opset_import[], producer_name, producer_version, domain, model_version, doc_string, graph[], metadata_props[], training_info[], functions[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelProto)
    initpos = position(e.io)
    x.ir_version != zero(Int64) && PB.encode(e, 1, x.ir_version)
    !isempty(x.opset_import) && PB.encode(e, 8, x.opset_import)
    !isempty(x.producer_name) && PB.encode(e, 2, x.producer_name)
    !isempty(x.producer_version) && PB.encode(e, 3, x.producer_version)
    !isempty(x.domain) && PB.encode(e, 4, x.domain)
    x.model_version != zero(Int64) && PB.encode(e, 5, x.model_version)
    !isempty(x.doc_string) && PB.encode(e, 6, x.doc_string)
    !isnothing(x.graph) && PB.encode(e, 7, x.graph)
    !isempty(x.metadata_props) && PB.encode(e, 14, x.metadata_props)
    !isempty(x.training_info) && PB.encode(e, 20, x.training_info)
    !isempty(x.functions) && PB.encode(e, 25, x.functions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelProto)
    encoded_size = 0
    x.ir_version != zero(Int64) && (encoded_size += PB._encoded_size(x.ir_version, 1))
    !isempty(x.opset_import) && (encoded_size += PB._encoded_size(x.opset_import, 8))
    !isempty(x.producer_name) && (encoded_size += PB._encoded_size(x.producer_name, 2))
    !isempty(x.producer_version) && (encoded_size += PB._encoded_size(x.producer_version, 3))
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 4))
    x.model_version != zero(Int64) && (encoded_size += PB._encoded_size(x.model_version, 5))
    !isempty(x.doc_string) && (encoded_size += PB._encoded_size(x.doc_string, 6))
    !isnothing(x.graph) && (encoded_size += PB._encoded_size(x.graph, 7))
    !isempty(x.metadata_props) && (encoded_size += PB._encoded_size(x.metadata_props, 14))
    !isempty(x.training_info) && (encoded_size += PB._encoded_size(x.training_info, 20))
    !isempty(x.functions) && (encoded_size += PB._encoded_size(x.functions, 25))
    return encoded_size
end

struct AttributeProto{T2<:Union{Nothing,var"##AbstractTypeProto"},T1<:Union{Nothing,var"##AbstractTypeProto"}} <: var"##AbstractAttributeProto"
    name::String
    ref_attr_name::String
    doc_string::String
    var"#type"::var"AttributeProto.AttributeType".T
    f::Float32
    i::Int64
    s::Vector{UInt8}
    t::Union{Nothing,TensorProto}
    g::Union{Nothing,GraphProto}
    sparse_tensor::Union{Nothing,SparseTensorProto}
    tp::T1
    floats::Vector{Float32}
    ints::Vector{Int64}
    strings::Vector{Vector{UInt8}}
    tensors::Vector{TensorProto}
    graphs::Vector{<:GraphProto}
    sparse_tensors::Vector{SparseTensorProto}
    type_protos::Vector{T2}
end
AttributeProto(;name = "", ref_attr_name = "", doc_string = "", var"#type" = var"AttributeProto.AttributeType".UNDEFINED, f = zero(Float32), i = zero(Int64), s = UInt8[], t = nothing, g = nothing, sparse_tensor = nothing, tp = nothing, floats = Vector{Float32}(), ints = Vector{Int64}(), strings = Vector{Vector{UInt8}}(), tensors = Vector{TensorProto}(), graphs = Vector{GraphProto}(), sparse_tensors = Vector{SparseTensorProto}(), type_protos = Vector{TypeProto}()) = AttributeProto(name, ref_attr_name, doc_string, var"#type", f, i, s, t, g, sparse_tensor, tp, floats, ints, strings, tensors, graphs, sparse_tensors, type_protos)
PB.default_values(::Type{AttributeProto}) = (;name = "", ref_attr_name = "", doc_string = "", var"#type" = var"AttributeProto.AttributeType".UNDEFINED, f = zero(Float32), i = zero(Int64), s = UInt8[], t = nothing, g = nothing, sparse_tensor = nothing, tp = nothing, floats = Vector{Float32}(), ints = Vector{Int64}(), strings = Vector{Vector{UInt8}}(), tensors = Vector{TensorProto}(), graphs = Vector{GraphProto}(), sparse_tensors = Vector{SparseTensorProto}(), type_protos = Vector{TypeProto}())
PB.field_numbers(::Type{AttributeProto}) = (;name = 1, ref_attr_name = 21, doc_string = 13, var"#type" = 20, f = 2, i = 3, s = 4, t = 5, g = 6, sparse_tensor = 22, tp = 14, floats = 7, ints = 8, strings = 9, tensors = 10, graphs = 11, sparse_tensors = 23, type_protos = 15)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AttributeProto})
    name = ""
    ref_attr_name = ""
    doc_string = ""
    var"#type" = var"AttributeProto.AttributeType".UNDEFINED
    f = zero(Float32)
    i = zero(Int64)
    s = UInt8[]
    t = Ref{Union{Nothing,TensorProto}}(nothing)
    g = Ref{Union{Nothing,GraphProto}}(nothing)
    sparse_tensor = Ref{Union{Nothing,SparseTensorProto}}(nothing)
    tp = Ref{Union{Nothing,TypeProto}}(nothing)
    floats = PB.BufferedVector{Float32}()
    ints = PB.BufferedVector{Int64}()
    strings = PB.BufferedVector{Vector{UInt8}}()
    tensors = PB.BufferedVector{TensorProto}()
    graphs = PB.BufferedVector{GraphProto}()
    sparse_tensors = PB.BufferedVector{SparseTensorProto}()
    type_protos = PB.BufferedVector{TypeProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 21
            ref_attr_name = PB.decode(d, String)
        elseif field_number == 13
            doc_string = PB.decode(d, String)
        elseif field_number == 20
            var"#type" = PB.decode(d, var"AttributeProto.AttributeType".T)
        elseif field_number == 2
            f = PB.decode(d, Float32)
        elseif field_number == 3
            i = PB.decode(d, Int64)
        elseif field_number == 4
            s = PB.decode(d, Vector{UInt8})
        elseif field_number == 5
            PB.decode!(d, t)
        elseif field_number == 6
            PB.decode!(d, g)
        elseif field_number == 22
            PB.decode!(d, sparse_tensor)
        elseif field_number == 14
            PB.decode!(d, tp)
        elseif field_number == 7
            PB.decode!(d, wire_type, floats)
        elseif field_number == 8
            PB.decode!(d, wire_type, ints)
        elseif field_number == 9
            PB.decode!(d, strings)
        elseif field_number == 10
            PB.decode!(d, tensors)
        elseif field_number == 11
            PB.decode!(d, graphs)
        elseif field_number == 23
            PB.decode!(d, sparse_tensors)
        elseif field_number == 15
            PB.decode!(d, type_protos)
        else
            PB.skip(d, wire_type)
        end
    end
    return AttributeProto(name, ref_attr_name, doc_string, var"#type", f, i, s, t[], g[], sparse_tensor[], tp[], floats[], ints[], strings[], tensors[], graphs[], sparse_tensors[], type_protos[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AttributeProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.ref_attr_name) && PB.encode(e, 21, x.ref_attr_name)
    !isempty(x.doc_string) && PB.encode(e, 13, x.doc_string)
    x.var"#type" != var"AttributeProto.AttributeType".UNDEFINED && PB.encode(e, 20, x.var"#type")
    x.f != zero(Float32) && PB.encode(e, 2, x.f)
    x.i != zero(Int64) && PB.encode(e, 3, x.i)
    !isempty(x.s) && PB.encode(e, 4, x.s)
    !isnothing(x.t) && PB.encode(e, 5, x.t)
    !isnothing(x.g) && PB.encode(e, 6, x.g)
    !isnothing(x.sparse_tensor) && PB.encode(e, 22, x.sparse_tensor)
    !isnothing(x.tp) && PB.encode(e, 14, x.tp)
    !isempty(x.floats) && PB.encode(e, 7, x.floats)
    !isempty(x.ints) && PB.encode(e, 8, x.ints)
    !isempty(x.strings) && PB.encode(e, 9, x.strings)
    !isempty(x.tensors) && PB.encode(e, 10, x.tensors)
    !isempty(x.graphs) && PB.encode(e, 11, x.graphs)
    !isempty(x.sparse_tensors) && PB.encode(e, 23, x.sparse_tensors)
    !isempty(x.type_protos) && PB.encode(e, 15, x.type_protos)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AttributeProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.ref_attr_name) && (encoded_size += PB._encoded_size(x.ref_attr_name, 21))
    !isempty(x.doc_string) && (encoded_size += PB._encoded_size(x.doc_string, 13))
    x.var"#type" != var"AttributeProto.AttributeType".UNDEFINED && (encoded_size += PB._encoded_size(x.var"#type", 20))
    x.f != zero(Float32) && (encoded_size += PB._encoded_size(x.f, 2))
    x.i != zero(Int64) && (encoded_size += PB._encoded_size(x.i, 3))
    !isempty(x.s) && (encoded_size += PB._encoded_size(x.s, 4))
    !isnothing(x.t) && (encoded_size += PB._encoded_size(x.t, 5))
    !isnothing(x.g) && (encoded_size += PB._encoded_size(x.g, 6))
    !isnothing(x.sparse_tensor) && (encoded_size += PB._encoded_size(x.sparse_tensor, 22))
    !isnothing(x.tp) && (encoded_size += PB._encoded_size(x.tp, 14))
    !isempty(x.floats) && (encoded_size += PB._encoded_size(x.floats, 7))
    !isempty(x.ints) && (encoded_size += PB._encoded_size(x.ints, 8))
    !isempty(x.strings) && (encoded_size += PB._encoded_size(x.strings, 9))
    !isempty(x.tensors) && (encoded_size += PB._encoded_size(x.tensors, 10))
    !isempty(x.graphs) && (encoded_size += PB._encoded_size(x.graphs, 11))
    !isempty(x.sparse_tensors) && (encoded_size += PB._encoded_size(x.sparse_tensors, 23))
    !isempty(x.type_protos) && (encoded_size += PB._encoded_size(x.type_protos, 15))
    return encoded_size
end

struct NodeProto <: var"##AbstractNodeProto"
    input::Vector{String}
    output::Vector{String}
    name::String
    op_type::String
    domain::String
    attribute::Vector{<:AttributeProto}
    doc_string::String
end
NodeProto(;input = Vector{String}(), output = Vector{String}(), name = "", op_type = "", domain = "", attribute = Vector{AttributeProto}(), doc_string = "") = NodeProto(input, output, name, op_type, domain, attribute, doc_string)
PB.default_values(::Type{NodeProto}) = (;input = Vector{String}(), output = Vector{String}(), name = "", op_type = "", domain = "", attribute = Vector{AttributeProto}(), doc_string = "")
PB.field_numbers(::Type{NodeProto}) = (;input = 1, output = 2, name = 3, op_type = 4, domain = 7, attribute = 5, doc_string = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NodeProto})
    input = PB.BufferedVector{String}()
    output = PB.BufferedVector{String}()
    name = ""
    op_type = ""
    domain = ""
    attribute = PB.BufferedVector{AttributeProto}()
    doc_string = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, input)
        elseif field_number == 2
            PB.decode!(d, output)
        elseif field_number == 3
            name = PB.decode(d, String)
        elseif field_number == 4
            op_type = PB.decode(d, String)
        elseif field_number == 7
            domain = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, attribute)
        elseif field_number == 6
            doc_string = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return NodeProto(input[], output[], name, op_type, domain, attribute[], doc_string)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NodeProto)
    initpos = position(e.io)
    !isempty(x.input) && PB.encode(e, 1, x.input)
    !isempty(x.output) && PB.encode(e, 2, x.output)
    !isempty(x.name) && PB.encode(e, 3, x.name)
    !isempty(x.op_type) && PB.encode(e, 4, x.op_type)
    !isempty(x.domain) && PB.encode(e, 7, x.domain)
    !isempty(x.attribute) && PB.encode(e, 5, x.attribute)
    !isempty(x.doc_string) && PB.encode(e, 6, x.doc_string)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NodeProto)
    encoded_size = 0
    !isempty(x.input) && (encoded_size += PB._encoded_size(x.input, 1))
    !isempty(x.output) && (encoded_size += PB._encoded_size(x.output, 2))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 3))
    !isempty(x.op_type) && (encoded_size += PB._encoded_size(x.op_type, 4))
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 7))
    !isempty(x.attribute) && (encoded_size += PB._encoded_size(x.attribute, 5))
    !isempty(x.doc_string) && (encoded_size += PB._encoded_size(x.doc_string, 6))
    return encoded_size
end

struct var"TypeProto.Sequence"{T1<:Union{Nothing,var"##AbstractTypeProto"}} <: var"##AbstractTypeProto.Sequence"
    elem_type::T1
end
var"TypeProto.Sequence"(;elem_type = nothing) = var"TypeProto.Sequence"(elem_type)
PB.default_values(::Type{var"TypeProto.Sequence"}) = (;elem_type = nothing)
PB.field_numbers(::Type{var"TypeProto.Sequence"}) = (;elem_type = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TypeProto.Sequence"})
    elem_type = Ref{Union{Nothing,TypeProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, elem_type)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TypeProto.Sequence"(elem_type[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TypeProto.Sequence")
    initpos = position(e.io)
    !isnothing(x.elem_type) && PB.encode(e, 1, x.elem_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TypeProto.Sequence")
    encoded_size = 0
    !isnothing(x.elem_type) && (encoded_size += PB._encoded_size(x.elem_type, 1))
    return encoded_size
end

struct TypeProto <: var"##AbstractTypeProto"
    value::Union{Nothing,OneOf{<:Union{var"TypeProto.Tensor",var"##AbstractTypeProto.Sequence",var"##AbstractTypeProto.Map",var"##AbstractTypeProto.Optional",var"TypeProto.SparseTensor"}}}
    denotation::String
end
TypeProto(;value = nothing, denotation = "") = TypeProto(value, denotation)
PB.oneof_field_types(::Type{TypeProto}) = (;
    value = (;tensor_type=var"TypeProto.Tensor", sequence_type=var"TypeProto.Sequence", map_type=var"TypeProto.Map", optional_type=var"TypeProto.Optional", sparse_tensor_type=var"TypeProto.SparseTensor"),
)
PB.default_values(::Type{TypeProto}) = (;tensor_type = nothing, sequence_type = nothing, map_type = nothing, optional_type = nothing, sparse_tensor_type = nothing, denotation = "")
PB.field_numbers(::Type{TypeProto}) = (;tensor_type = 1, sequence_type = 4, map_type = 5, optional_type = 9, sparse_tensor_type = 8, denotation = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TypeProto})
    value = nothing
    denotation = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            value = OneOf(:tensor_type, PB.decode(d, Ref{var"TypeProto.Tensor"}))
        elseif field_number == 4
            value = OneOf(:sequence_type, PB.decode(d, Ref{var"TypeProto.Sequence"}))
        elseif field_number == 5
            value = OneOf(:map_type, PB.decode(d, Ref{var"TypeProto.Map"}))
        elseif field_number == 9
            value = OneOf(:optional_type, PB.decode(d, Ref{var"TypeProto.Optional"}))
        elseif field_number == 8
            value = OneOf(:sparse_tensor_type, PB.decode(d, Ref{var"TypeProto.SparseTensor"}))
        elseif field_number == 6
            denotation = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return TypeProto(value, denotation)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TypeProto)
    initpos = position(e.io)
    if isnothing(x.value);
    elseif x.value.name === :tensor_type
        PB.encode(e, 1, x.value[])
    elseif x.value.name === :sequence_type
        PB.encode(e, 4, x.value[])
    elseif x.value.name === :map_type
        PB.encode(e, 5, x.value[])
    elseif x.value.name === :optional_type
        PB.encode(e, 9, x.value[])
    elseif x.value.name === :sparse_tensor_type
        PB.encode(e, 8, x.value[])
    end
    !isempty(x.denotation) && PB.encode(e, 6, x.denotation)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TypeProto)
    encoded_size = 0
    if isnothing(x.value);
    elseif x.value.name === :tensor_type
        encoded_size += PB._encoded_size(x.value[], 1)
    elseif x.value.name === :sequence_type
        encoded_size += PB._encoded_size(x.value[], 4)
    elseif x.value.name === :map_type
        encoded_size += PB._encoded_size(x.value[], 5)
    elseif x.value.name === :optional_type
        encoded_size += PB._encoded_size(x.value[], 9)
    elseif x.value.name === :sparse_tensor_type
        encoded_size += PB._encoded_size(x.value[], 8)
    end
    !isempty(x.denotation) && (encoded_size += PB._encoded_size(x.denotation, 6))
    return encoded_size
end

struct var"TypeProto.Optional" <: var"##AbstractTypeProto.Optional"
    elem_type::Union{Nothing,TypeProto}
end
var"TypeProto.Optional"(;elem_type = nothing) = var"TypeProto.Optional"(elem_type)
PB.default_values(::Type{var"TypeProto.Optional"}) = (;elem_type = nothing)
PB.field_numbers(::Type{var"TypeProto.Optional"}) = (;elem_type = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TypeProto.Optional"})
    elem_type = Ref{Union{Nothing,TypeProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, elem_type)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TypeProto.Optional"(elem_type[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TypeProto.Optional")
    initpos = position(e.io)
    !isnothing(x.elem_type) && PB.encode(e, 1, x.elem_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TypeProto.Optional")
    encoded_size = 0
    !isnothing(x.elem_type) && (encoded_size += PB._encoded_size(x.elem_type, 1))
    return encoded_size
end

struct var"TypeProto.Map" <: var"##AbstractTypeProto.Map"
    key_type::Int32
    value_type::Union{Nothing,TypeProto}
end
var"TypeProto.Map"(;key_type = zero(Int32), value_type = nothing) = var"TypeProto.Map"(key_type, value_type)
PB.default_values(::Type{var"TypeProto.Map"}) = (;key_type = zero(Int32), value_type = nothing)
PB.field_numbers(::Type{var"TypeProto.Map"}) = (;key_type = 1, value_type = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TypeProto.Map"})
    key_type = zero(Int32)
    value_type = Ref{Union{Nothing,TypeProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            key_type = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, value_type)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TypeProto.Map"(key_type, value_type[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TypeProto.Map")
    initpos = position(e.io)
    x.key_type != zero(Int32) && PB.encode(e, 1, x.key_type)
    !isnothing(x.value_type) && PB.encode(e, 2, x.value_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TypeProto.Map")
    encoded_size = 0
    x.key_type != zero(Int32) && (encoded_size += PB._encoded_size(x.key_type, 1))
    !isnothing(x.value_type) && (encoded_size += PB._encoded_size(x.value_type, 2))
    return encoded_size
end

struct ValueInfoProto <: var"##AbstractValueInfoProto"
    name::String
    var"#type"::Union{Nothing,TypeProto}
    doc_string::String
end
ValueInfoProto(;name = "", var"#type" = nothing, doc_string = "") = ValueInfoProto(name, var"#type", doc_string)
PB.default_values(::Type{ValueInfoProto}) = (;name = "", var"#type" = nothing, doc_string = "")
PB.field_numbers(::Type{ValueInfoProto}) = (;name = 1, var"#type" = 2, doc_string = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ValueInfoProto})
    name = ""
    var"#type" = Ref{Union{Nothing,TypeProto}}(nothing)
    doc_string = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, var"#type")
        elseif field_number == 3
            doc_string = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ValueInfoProto(name, var"#type"[], doc_string)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ValueInfoProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isnothing(x.var"#type") && PB.encode(e, 2, x.var"#type")
    !isempty(x.doc_string) && PB.encode(e, 3, x.doc_string)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ValueInfoProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isnothing(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 2))
    !isempty(x.doc_string) && (encoded_size += PB._encoded_size(x.doc_string, 3))
    return encoded_size
end

struct TrainingInfoProto <: var"##AbstractTrainingInfoProto"
    initialization::Union{Nothing,GraphProto}
    algorithm::Union{Nothing,GraphProto}
    initialization_binding::Vector{StringStringEntryProto}
    update_binding::Vector{StringStringEntryProto}
end
TrainingInfoProto(;initialization = nothing, algorithm = nothing, initialization_binding = Vector{StringStringEntryProto}(), update_binding = Vector{StringStringEntryProto}()) = TrainingInfoProto(initialization, algorithm, initialization_binding, update_binding)
PB.default_values(::Type{TrainingInfoProto}) = (;initialization = nothing, algorithm = nothing, initialization_binding = Vector{StringStringEntryProto}(), update_binding = Vector{StringStringEntryProto}())
PB.field_numbers(::Type{TrainingInfoProto}) = (;initialization = 1, algorithm = 2, initialization_binding = 3, update_binding = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TrainingInfoProto})
    initialization = Ref{Union{Nothing,GraphProto}}(nothing)
    algorithm = Ref{Union{Nothing,GraphProto}}(nothing)
    initialization_binding = PB.BufferedVector{StringStringEntryProto}()
    update_binding = PB.BufferedVector{StringStringEntryProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, initialization)
        elseif field_number == 2
            PB.decode!(d, algorithm)
        elseif field_number == 3
            PB.decode!(d, initialization_binding)
        elseif field_number == 4
            PB.decode!(d, update_binding)
        else
            PB.skip(d, wire_type)
        end
    end
    return TrainingInfoProto(initialization[], algorithm[], initialization_binding[], update_binding[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TrainingInfoProto)
    initpos = position(e.io)
    !isnothing(x.initialization) && PB.encode(e, 1, x.initialization)
    !isnothing(x.algorithm) && PB.encode(e, 2, x.algorithm)
    !isempty(x.initialization_binding) && PB.encode(e, 3, x.initialization_binding)
    !isempty(x.update_binding) && PB.encode(e, 4, x.update_binding)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TrainingInfoProto)
    encoded_size = 0
    !isnothing(x.initialization) && (encoded_size += PB._encoded_size(x.initialization, 1))
    !isnothing(x.algorithm) && (encoded_size += PB._encoded_size(x.algorithm, 2))
    !isempty(x.initialization_binding) && (encoded_size += PB._encoded_size(x.initialization_binding, 3))
    !isempty(x.update_binding) && (encoded_size += PB._encoded_size(x.update_binding, 4))
    return encoded_size
end

struct FunctionProto <: var"##AbstractFunctionProto"
    name::String
    input::Vector{String}
    output::Vector{String}
    attribute::Vector{String}
    node::Vector{<:NodeProto}
    doc_string::String
    opset_import::Vector{OperatorSetIdProto}
    domain::String
end
FunctionProto(;name = "", input = Vector{String}(), output = Vector{String}(), attribute = Vector{String}(), node = Vector{NodeProto}(), doc_string = "", opset_import = Vector{OperatorSetIdProto}(), domain = "") = FunctionProto(name, input, output, attribute, node, doc_string, opset_import, domain)
PB.reserved_fields(::Type{FunctionProto}) = (names = ["since_version", "status"], numbers = Union{Int,UnitRange{Int}}[2, 3])
PB.default_values(::Type{FunctionProto}) = (;name = "", input = Vector{String}(), output = Vector{String}(), attribute = Vector{String}(), node = Vector{NodeProto}(), doc_string = "", opset_import = Vector{OperatorSetIdProto}(), domain = "")
PB.field_numbers(::Type{FunctionProto}) = (;name = 1, input = 4, output = 5, attribute = 6, node = 7, doc_string = 8, opset_import = 9, domain = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FunctionProto})
    name = ""
    input = PB.BufferedVector{String}()
    output = PB.BufferedVector{String}()
    attribute = PB.BufferedVector{String}()
    node = PB.BufferedVector{NodeProto}()
    doc_string = ""
    opset_import = PB.BufferedVector{OperatorSetIdProto}()
    domain = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, input)
        elseif field_number == 5
            PB.decode!(d, output)
        elseif field_number == 6
            PB.decode!(d, attribute)
        elseif field_number == 7
            PB.decode!(d, node)
        elseif field_number == 8
            doc_string = PB.decode(d, String)
        elseif field_number == 9
            PB.decode!(d, opset_import)
        elseif field_number == 10
            domain = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return FunctionProto(name, input[], output[], attribute[], node[], doc_string, opset_import[], domain)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FunctionProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.input) && PB.encode(e, 4, x.input)
    !isempty(x.output) && PB.encode(e, 5, x.output)
    !isempty(x.attribute) && PB.encode(e, 6, x.attribute)
    !isempty(x.node) && PB.encode(e, 7, x.node)
    !isempty(x.doc_string) && PB.encode(e, 8, x.doc_string)
    !isempty(x.opset_import) && PB.encode(e, 9, x.opset_import)
    !isempty(x.domain) && PB.encode(e, 10, x.domain)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FunctionProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.input) && (encoded_size += PB._encoded_size(x.input, 4))
    !isempty(x.output) && (encoded_size += PB._encoded_size(x.output, 5))
    !isempty(x.attribute) && (encoded_size += PB._encoded_size(x.attribute, 6))
    !isempty(x.node) && (encoded_size += PB._encoded_size(x.node, 7))
    !isempty(x.doc_string) && (encoded_size += PB._encoded_size(x.doc_string, 8))
    !isempty(x.opset_import) && (encoded_size += PB._encoded_size(x.opset_import, 9))
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 10))
    return encoded_size
end
